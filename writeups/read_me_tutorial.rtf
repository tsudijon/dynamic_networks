{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid402\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid701\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid8}
{\list\listtemplateid9\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid9}
{\list\listtemplateid10\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid10}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}{\listoverride\listid9\listoverridecount0\ls9}{\listoverride\listid10\listoverridecount0\ls10}}
\margl1440\margr1440\vieww10800\viewh11820\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 BP: May 28, 2018\
Read this FULLY to understand the implementation of our method for detecting periodicity in dynamic networks.\
\
##################################################\

\b0 I have split the functions into various modules in terms of what they do in our method. They are all in 
\b shared_scripts
\b0  folder. I intended shared_scripts to have the functions that we call in repeatedly. The contents are as follows:
\b \
\

\b0 a) 
\b general_file_fns
\b0 :
\b  
\b0 This utilizes the pickle module to easily save/load .p files.\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 {\listtext	a.	}
\b load_file
\b0 : load a .p file\
{\listtext	b.	}
\b save_file
\b0 : save a .p file\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
b)  
\b graph_fns: 
\b0 This module contains the functions that we can use to modify graphs.  The phi functions and the function used to apply the phi function to our sequence of graphs are here.  I also added functions from 
\b Chris\'92 GlobalPeriodicGraphs.py
\b0  script here for convenience.\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls2\ilvl0\cf0 {\listtext	a.	}
\b all the phi fns:
\b0  soft plus, shifted_inv_fn etc\
{\listtext	b.	}
\b weight_fn:  
\b0 apply a phi function to a graph. One can either use the pre-made phi functions or pass a phi function in the form of python lambda function. \
{\listtext	c.	}
\b getTorusadj: 
\b0 construct a NxN torus grid; from Chris\'92 code
\b \
\ls2\ilvl0
\b0 {\listtext	d.	}
\b draw2dGraph: 
\b0 draw the Torus grid graph; from Chris\'92 code
\b \
\ls2\ilvl0
\b0 {\listtext	e.	}
\b interpolateStates: 
\b0 Linearly interpolate between two scalar functions V1 and V2; from Chris\'92 code
\b \
\ls2\ilvl0
\b0 {\listtext	f.	}
\b getRandomPosIdxs: 
\b0 Choose a random 2x2 location on a KxK torus; from Chris\'92 code
\b \
\ls2\ilvl0
\b0 {\listtext	g.	}
\b getBlinkingVideo: 
\b0  Make a video of four dots blinking down to 4, 3, 2, 1, 0 and then back\
{\listtext	h.	}    at random positions on a KxK torus graph; from Chris\'92 code
\b \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0 \cf0 \
\
c) 
\b persistence_fns: 
\b0 This module contains functions that relate to persistence homology.\
\pard\tx224\tx607\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li702\fi-703\pardirnatural\partightenfactor0
\ls3\ilvl0
\b \cf0 {\listtext	
\b0 a.
\b 	}get_filtration:
\b0  construct a valid filtration from edge and node weights.\
\ls3\ilvl0
\b {\listtext	
\b0 b.
\b 	}get_rips_complex:
\b0  construct a rips complex from a filtration matrix\
\ls3\ilvl0
\b {\listtext	
\b0 c
\b .	}get_bottleneck_dist:
\b0  compute bottleneck distance between a couple of barcodes\
\ls3\ilvl0
\b {\listtext	
\b0 d
\b .	}get_bottleneck_dist_matrix: 
\b0 construct the bottleneck distance matrix for a sequence of barcodes\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
d) 
\b sliding_window_fns: 
\b0 This module contains functions that relate to sliding window embedding\
\pard\tx238\tx618\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li447\fi-448\pardirnatural\partightenfactor0
\ls4\ilvl0
\b \cf0 {\listtext	
\b0 a.
\b 	}sliding_window: 
\b0 construct a sliding window embedding for a time series. In our case, we construct a sliding window embedding of a time series of barcodes.\
{\listtext	b.
\b 	}
\b0 sw_distance_matrix: construct the distance matrix for a sequence of sliding window vectors (each component of a sliding window vector is a barcode).
\b \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
#################################################################\

\b0 Implementation of our method is in 
\b tutorial.py
\b0  script. Below, I explain the 
\b tutorial.py
\b0  script in detail.
\b \
\

\b0 Currently our pipeline looks like this:\
a) We pass in our graph in the form of edge weights and node weights.  We are only dealing with undirected graphs, so our adjacency matrix is symmetric. We pass only the upper triangular portion of the adjacency matrix. We pass in a sequence of the edge weights and node weights.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i \cf0 >>> node_wts = [[1, 2, 3], [3, 4, 5, 6], [1, 2, 5, 4], [1, 5, 2, 3], [3, 1, 8, 6, 5]]\
>>> edge_wts = [[5, 4, 2], [4, 5, 5, 6, 6, 1], [4, 5, 5, 6, 6, 1], [2, 5, 3, 9, 8, 1],\
            [3, 8, 6, 1, 2, 4, 7, 2, 7, 4]]\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i0 \cf0 b) We pass the edge weights and node weights thru a phi function that is monotonically decreasing.\
Here phi can be shifted arctan, exp decay, relu etc.  The 
\b weight_fn
\b0  does this.  It is in the graph_fns (gf) module. \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i \cf0 >>> phi_node_wts, phi_edge_wts = gf.weight_fn(node_wts, edge_wts, lamda=1, phi='softplus')\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i0 \cf0 c)  Next, we get a valid filtration matrix, a symmetric matrix.  The filtration matrix contains the weights between any two vertices x and y, such that weight between any two vertices x and y, \
	w(x, y) = max(wv(x), wv(y), we(x, y)).\
						where,\
						wv(x) = node weight of x\
						we(x, y) = node weight between x and y\
\
The 
\b get_filtration(node weight, edge weight)
\b0  does this.  This function acts on a single graph. It is in the persistence_fns (pf) module.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i \cf0 >>> filtration_matrix = list(map(lambda n, e: pf.get_filtration(n, e), phi_node_wts, phi_edge_wts))\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i0 \cf0 d) Next, we create rips complexes from the filtration matrix.  The 
\b get_rips_complex(filtration matrix)
\b0  function does this. It takes in a filtration matrix and turns it into a rips complex. Dionysus was used to create this function.  The function is in persistence_fns (pf) module. \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i \cf0 >>> rips = list(map(pf.get_rips_complex, filtration_matrix))
\i0  \
\
\
e) Next, we get a sequence of H0 barcodes from these sequence of rips complexes that we created for our sequence of graphs. Dionysus (dns) was used to do this.\

\i >>> hom = list(map(dns.homology_persistence, rips))\
>>> dgms = list(map(lambda h, r: dns.init_diagrams(h, r)[0], hom, rips))\
>>> barcodes = [[[point.birth, point.death] for point in dgm] for dgm in dgms]\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i0 \cf0 f) We get a bottleneck distance matrix between the sequence of H0 barcode. The 
\i\b get_bottleneck_dist_matrix(seq. of barcodes)
\i0\b0   function does this.  We use Gudhi to compute bottleneck distances. It is in the persistence_fns (pf) module.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i \cf0 >>> bn_dist_matrix = pf.get_bottleneck_dist_matrix(barcodes)\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i0 \cf0 g) We run a sliding window embedding on the sequence of barcodes and build a distance matrix between the sliding window vectors.  We can do this in two ways.\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls5\ilvl0
\i \cf0 {\listtext	a.	}
\i0 We can first create a sliding window embedding for the sequence of H0 barcodes.  The 
\b sliding_window(seq. of barcodes, d, tau) 
\b0 function does this.\
\pard\tx940\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li1440\fi-1440\pardirnatural\partightenfactor0
\ls5\ilvl1
\i \cf0 	>>> sw_vecs = sw.sliding_window(barcodes, d=2, tau=2)\
		\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls5\ilvl1
\i0 \cf0 		Then, we can find the bottleneck distance between two sliding window vectors: We find the bottleneck distance between the corresponding components of the sliding window vectors.  Then, we can take the L2 norm of that. The 
\b sw_distance_matrix(seq of sliding window vectors)
\b0  function does this.
\i 	\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls5\ilvl0\cf0 		>>> sw_dist_matrix = sw.sw_distance_matrix(sw_vecs) \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	Both 
\i0 the functions are in sliding_window_fns (sw) module.\
\
	NOTE: If this method is used, we don\'92t need to find the bottleneck distance matrix and 	skip (f). This method is computationally costlier since we have to compute bottleneck 	distance for the same pair of barcodes multiple times.\

\i \
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls6\ilvl0\cf0 {\listtext	b.	}
\i0 If the bottleneck distance matrix is available (if (f) is done), we can just run a sliding window embedding on the indices of the sequence of the barcodes.  Then, we can use the bottleneck distance matrix from (f) in conjunction with the indices of the sliding window vectors to compute the distances between the vectors.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i \cf0 	>>> sw_vecs_indices = sw.sliding_window(range(len(barcodes)), d=2, tau=2)\
	>>> sw_dist_matrix1 = sw.sw_distance_matrix(sw_vecs_indices, bn_dist_matrix)\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i0 \cf0 	NOTE: The same 
\b sw_distance_matrix function(seq of sliding window vets, bottleneck 	distance matrix)
\b0  as above can do this. If the bottleneck distance matrix is given and the 	indices of the sliding window embedding is passed, it can automatically use that to find the 	distance matrix between the sliding window vectors.\
\
h) Finally, we find the H0/H1/H2 barcodes for the sliding window distance matrix using ripser. This is Chris\'92 ripser (r) wrapper. The 
\b doRipsFiltrationDM
\b0  function can do this.\
>>> 
\i PDs = r.doRipsFiltrationDM(sw_dist_matrix, maxHomDim=1, coeff=2)\
\

\i0 i) Finally, we can plot the H0/H1/H2 barcodes and see what we have.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i \cf0 >>> fig = plt.figure()\
>>> ax = fig.add_subplot(111)\
>>> plt.title('H1')\
>>> tdap.plotDGM(PDs[1])\
>>> plt.tight_layout()\
>>> plt.show()
\i0 \

\i \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i0 \cf0 ####################################################\
Use on datasets.\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls7\ilvl0\cf0 {\listtext	a.	}
\b MIT dataset: 
\b0 The implementation is in MIT_dataset folder.  The most current implementation is in 2018_04_updated_sw folder. The 
\b save_MIT_data.py
\b0  contains code to save the binned MIT data that Tim made using R to a .p file. The rest is legacy code i.e. work from the summer. \
{\listtext	b.	}
\b Neuroscience dataset: 
\b0 It is in neuroscience folder. I only have the work from summer there. We should move away from neuroscience for now.\
{\listtext	c.	}
\b 2d_graph_example: 
\b0 It contains Chris\'92 2D graph example. It uses the most updated version of our implementation.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
###########################################################\
Other imp. folders\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls8\ilvl0\cf0 {\listtext	b.	}
\b shared_scripts: 
\b0 contains functions that are repeatedly used.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
###########################################################\
Legacy code i.e. old implementation code. It is work from summer.\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls9\ilvl0\cf0 {\listtext	a.	}
\b pipeline_fns:
\b0  contains code for the implementation of an old version of our method.\
{\listtext	b.	}
\b ripser:
\b0  It contains the ripser module. It is legacy and can be deleted.\
{\listtext	c.	}
\b simple_egs: 
\b0 Simple graph examples from the summer\
{\listtext	d.	}
\b pyRipser: 
\b0 It contains Chris\'92 wrapper code from summer.  I use a local version to compute barcodes, so this is useless. The implementation is wonky because it requires an absolute path to be given.  I suggest moving to the newer pip version of ripser in the future.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
#######################################################\

\b ISSUES\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls10\ilvl0
\b0 \cf0 {\listtext	a.	}Path Issues: I use absolute paths (i.e. paths that are specific to my computer) to call the functions in my scripts.  We need to come up with a solution that doesn\'92t use absolute paths. This is a problem for using the ripser module and calling graph_fns/persistence_fns/sw_fns for the current scripts.  This code won\'92t work for others if the right path variables aren\'92t given.\
{\listtext	b.	}Using ripser: We should use newer pip version of ripper in the future. I use a local version of the old ripser wrapper to compute barcodes.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 ############################\
\
}